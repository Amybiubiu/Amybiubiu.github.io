<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS 异步]]></title>
    <url>%2F2020%2F01%2F23%2FJS-%E5%BC%82%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[什么是异步12setTimeout(()=&gt;&#123;console.log("路")&#125;,1000);console.log("遥"); // 遥路在1000s的时间（需要较长时间响应的事件）内执行了下一块代码。正确说法：任何时候，只要把一段代码包装成一个函数，并指定它在响应某个事件(定时器、鼠标点 击、Ajax 响应等)时执行，你就是在代码中创建了一个将来执行的块，也由此在这个程序 中引入了异步机制。 传统的实现异步的方式 回调 其他 为什么我们会需要使用异步，因为我们不想浏览器发生阻塞，想象我们手机卡住的场景，这简直难以忍受；但是通过回调引发的异步同样会引发新的问题（当然，这些问题与引起的阻塞相比都是小问题）。（其中影响最大的“信任问题”。） 回调引发的问题顺序问题-&gt;追踪难度加大12345678doA(function()&#123; doC(); doD(function()&#123; doF(); &#125;); doE();&#125; );doB(); 或许能够追踪到A → B → C → D → E → F这样的执行顺序，可是真正的异步实际情况会复杂很多。而且在某些情况下，doA顺序执行了，而在你的代码中，函数的执行结果很依赖于各个函数的执行顺序，这时候你很难追踪到是那个部分出了问题。当然也可以通过硬编码（调整函数代码块的位置和设置if语句）去排除这些问题，但是这样就将代码复杂化了。所以我们需要更好的异步模式。 信任问题12345//Aajax("..",function(...)&#123; //C&#125;);//B 有时候 ajax(..)(也 就是你交付回调 continuation 的第三方)不是你编写的代码，也不在你的直接控制下。多数情况下，它是某个第三方提供的工具。我们把这称为控制反转(inversion of control)，也就是把自己程序一部分的执行控制交给某个第三方。(出现的不可信任的第三方)。由于某些原因，c没有回调成功，执行ajax这个工具进行了会在五秒钟内每秒重试一次传入的回调函数，然后才会因超时而失败。之后这5个回调成功了，c被执行了5次。如果c是一个支付相关的，则用户会被扣款五次。当然这也可以通过设置if条件，防止第三方工具瞎搞。出了重复回调外，还会有其他问题 调用回调过早(在追踪之前) 调用回调过晚(或没有调用) 调用回调的次数太少或太多(就像你遇到过的问题!) 没有把所需的环境 / 参数成功传给你的回调函数 吞掉可能出现的错误或异常 为了解决这一系例隐患，我们不知道要增加多少工作量，所以我们迫切需要新的异步模式！ 新的异步模式Promise在 ES6 中，有一个新的概念建立在事件循环队列之上，叫作任务队列(job queue)。事件循环队列类似于一个游乐园游戏:玩过了一个游戏之后，你需要重新到队尾排队才能 再玩一次。而任务队列类似于玩过了游戏之后，插队接着继续玩。一个 Promise (p1)决议后，这个 Promise 上所有的通过 then(..) 注册的回调(cb1,cb2)都会在下一个异步时机点(p2 cb3)上依次被立即调用。这些回调中的任意一个(cb1)都无法影响或延误对其他回调(cb2)的调用。由Promise创建的then异步是基于任务的，而不像cb是基于事件的。 什么是Promise promise作为一个返回值 1234567891011function foo(x)&#123; //构造并返回一个promise return new Promise( function(resolve,reject)&#123; //promise的决议回调 &#125; )&#125;//new Promise( function(..)&#123; .. &#125; )模式//？ promise事件 123456789101112131415//相比回调，实现了控制反转，bar不再通过foo的成功调用var p = foo(2);bar(p);baz(p);function bar(fooPromise)&#123; fooPromise.then( function()&#123; //foo success &#125;, function()&#123; //foo err &#125; );&#125;//baz 同 理解then(…)具有then（）函数的对象，都是promise吗？不是。普通then（）与promise产生的then的区别？ 123456789101112131415var p = &#123; then: function(cb,errb)&#123; cb(42); errb("evil laugh"); &#125;&#125;;p.then( function fulfilled(val)&#123; console.log(val); //42 &#125;, function rejected(err)&#123; console.log(err); //evil laugh //如果是真正promise的then方法，这两个是不会都运行的 &#125;) Promise如何解决了之前的问题，你看出来了吗关于信任问题 12345678910111213//Promise 构造器var p = new Promise( function(resolve,reject)&#123; resolve(42); reject();&#125;)p.then( function fulfill(x1)&#123; console.log(x1);//完成后 42 &#125;, function reject(x2)&#123; console.err(x2); &#125;) 回调未调用reject事件但如果Promise永远不被决议呢，Promise提供了解决方案，一种称为竞态的解决方案 调用次数过多或过少由于 Promise 只能被决议一次，且决议后的结果不会被更改，所以任何通过 then(..) 注册的(每个)回调就只会被调用一次。如果你把同一个回调注册了不止一次(比如p.then(f); p.then(f);)，那它被调用的次数就会和注册次数相同 调用过晚在下一个异步点之前一定会结束这个任务。 未能传递参数/环境值依靠注册的回调传递 吞掉错误或异常reject能捕捉到 123456789101112var p = new Promise( function(resolve,reject)&#123; foo.bar(); //foo undefined resolve(42);&#125; )p.then( function fufilled()&#123; //will not reach here &#125;, function rejected(err)&#123; // err将会是一个TypeError异常对象来自foo.bar()这一行 &#125;) 如何将传统的回调异步转换为Promise异步模式12345678910111213141516171819202122232425262728293031323334353637383940//回调function add(getX,getY,cb)&#123; var x,y; getX(function(xval)&#123; x = xval; if(y != undefined)&#123; cb(x+y); &#125; &#125;)//这种写法？getX里面是一个函数？莫非是高阶函数？xval应该是fetchX的返回结果 getY(function(yVal)&#123; y =yVal; if(x != undifined)&#123; cb( x+y); &#125; &#125;)&#125;add(fetchX,fetchY,function(sum)&#123; console,log(sum);&#125;)//Promise模式function add(xPromise,yPromise) &#123; return Promise.all([xPromise,yPromise]).then( function(valus)&#123; //.then会返回一个promise,这个promise由return values[0] + values[1]这一 行立即决议(得到加运算的结果) return values[0]+values[1]; &#125; //fulfill(values[0]+values[1]); )&#125;add( fetchX(),fetchY() ).then( function(sum)&#123; console.log( sum ); &#125;, function(err)&#123; console.error(err); &#125;);//通过Promise API学习使用 Promise的不足其一为了避免丢失被忽略和抛弃的 Promise 错误，一些开发者表示，Promise 链的一个最佳实践 就是最后总以一个 catch(..) 结束，比如 123456789var p = Promise.resolve(42);p.then( function fufill(msg)&#123; // 数字没有string函数，所以会抛出错误 console.log( msg.toLowerCase()) &#125;).catch( handleErrors);//如果 handleErrors(..) 本身内部也有错误怎么办呢?谁来捕捉它?]]></content>
  </entry>
  <entry>
    <title><![CDATA[this]]></title>
    <url>%2F2019%2F11%2F22%2Fthis%2F</url>
    <content type="text"><![CDATA[绑定规则找到调用位置后，我们还需根据绑定规则确定 this 的绑定对象。默认绑定最常用的函数调用类型：独立函数调用。无法应用其他规则的默认规则。12345function foo() &#123; console.log(this.a);&#125;var a = 2;foo(); //2在代码中，foo() 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用 默认绑定，无法应用其他规则。如果使用严格模式(strict mode)，那么全局对象将无法使用默认绑定，因此 this 会绑定 到 undefined;严格模式下与 foo() 的调用位置无关: 123456789function foo() &#123; console.log(this.a);&#125;var a = 2;(function() &#123; "use strict"; foo(); // 2&#125;)();//不过在代码中混用严格模式和非严格模式的行为是不可取的。 隐式绑定另一条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含，不过这种说法可能会造成一些误导。 12345678function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2, foo: foo&#125;;obj.foo(); 调用位置会使用 obj 上下文来引用函数，因此你可以说函数被调用时 obj 对象“拥 有”或者“包含”它。当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调用 foo() 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的。 隐式丢失指的是被隐式绑定的函数丢失绑定对象，而应用默认绑定的情形。而默认绑定把 this 绑定到全局对象或者 undifined 上，取决于是否为严格模式。 1234567891011function ()&#123; console.log(this.a);&#125;var obj = &#123; a:2; foo:foo;&#125;var bar = obj.foo; //函数别名var a ="global"bar(); //"global" 虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的 bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。 显式绑定如果我们不想在对象内部包含函数引用，而想在某个对象上强制调用函数，该怎么做呢?可以使用函数的 call(..) 和 apply(..) 方法。 1234567function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2&#125;;foo.call(obj); //2 通过 foo.call(..)，我们可以在调用 foo 时强制把它的 this 绑定到 obj 上。 硬绑定显式绑定仍然无法解决我们之前提出的丢失绑定问题。（硬绑定例子对比那隐式丢失的例子）。但是显式绑定的一个变种可以解决这个问题。 1234567891011121314function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2&#125;;var bar = function() &#123; foo.call(obj);&#125;;bar(); //2//硬绑定bar不能修改foo的this指向了bar.call(window); //2 由于硬绑定是一种非常常用的模式，所以在 ES5 中提供了内置的方法 Function.prototype. bind，它的用法如下: 12345678910function foo(something) &#123; console.log( this.a, something ); return this.a + something;&#125; var obj = &#123; a:2&#125;;var bar = foo.bind( obj );var b = bar( 3 ); // 2 3 console.log( b ); // 5 bind(..) 会返回一个硬编码的新函数，它会把参数设置为 this 的上下文并调用原始函数。 new 绑定使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 创建(或者说构造)一个全新的对象。 这个新对象会被执行[[ 原型 ]]连接。 这个新对象会绑定到函数调用的 this。 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。 12345function foo(a) &#123; this.a = a;&#125;var bar = new foo(2);console.log(bar.a); //2 使用 new 来调用 foo(..) 时，我们会构造一个新对象（_这个新对象名为 bar_）并把它绑定到 foo(..) 调用中的 this 上。 绑定规则的优先级当两种绑定同时出现时，我们则需要比较它们的优先级 123456789101112131415function foo() &#123; console.log(this.a);&#125;var obj1 = &#123; a: 2, foo: foo&#125;;var obj2 = &#123; a: 3, foo: foo&#125;;obj1.foo.call(obj2); // 3obj2.foo.call(obj1); // 2//可以看到，显式绑定优先级更高 函数是否在 new 中调用(new 绑定)?如果是的话 this 绑定的是新创建的对象。var bar = new foo() 函数是否通过 call、apply(显式绑定)或者硬绑定调用?如果是的话，this 绑定的是 指定的对象。var bar = foo.call(obj2) 函数是否在某个上下文对象中调用(隐式绑定)?如果是的话，this 绑定的是那个上 下文对象。var bar = obj1.foo() 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到 全局对象。var bar = foo() 箭头函数的 this 指向箭头函数不使用 this 的四种标准规则，而是根据外层(函数或者全局)作用域来决 定 this。 1234567891011121314function foo()&#123; return (a) =&gt; &#123; console.log(this.a); &#125;;&#125;var obj1 =&#123; a:2;&#125;var obj2 =&#123; a:3;&#125;var bar = foo.call(obj);bar.call(obj2); //2 foo() 内部创建的箭头函数会捕获调用时 foo() 的 this。由于 foo() 的 this 绑定到 obj1， bar(引用箭头函数)的 this 也会绑定到 obj1，箭头函数的绑定无法被修改。(new 也不 行!) 箭头函数可以像 bind(..) 一样确保函数的 this 被绑定到指定对象，此外，其重要性还体 现在它用更常见的词法作用域取代了传统的 this 机制。实际上，在 ES6 之前我们就已经 在使用一种几乎和箭头函数完全一样的模式。 123456789101112131415161718192021function foo() &#123; setTimeout(() =&gt; &#123;// 这里的 this 在此法上继承自 foo() console.log( this.a ); &#125;,100);&#125;var obj = &#123; a:2&#125;;foo.call( obj ); // 2function foo() &#123; var self = this; // lexical capture of this setTimeout( function()&#123; console.log( self.a ); &#125;, 100 );&#125;var obj = &#123; a: 2&#125;;foo.call( obj ); // 2 虽然 self = this 和箭头函数看起来都可以取代 bind(..)，但是从本质上来说，它们想替 代的是 this 机制。如果你经常编写 this 风格的代码，但是绝大部分时候都会使用 self = this 或者箭头函数 来否定 this 机制，那你或许应当: 只使用词法作用域并完全抛弃错误this风格的代码; 完全采用 this 风格，在必要时使用 bind(..)，尽量避免使用 self = this 和箭头函数.]]></content>
  </entry>
  <entry>
    <title><![CDATA[作用域]]></title>
    <url>%2F2019%2F11%2F13%2F%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[在JS程序的编译及执行过程中：作用域是一个怎样的概念【无论在程序的编译阶段还是运行阶段都 在编译阶段要，查询变量（询问作用域，作用域的两种模型静态和动态）和变量解析，变量解析涉及到两种方式，lhs 和 rsh 这两者的共同点是都遵循作用域链（作用域是怎样形成结构，需要分析所处的位置，即块级函数全局），则查找，查找不到会怎样？编译器自己声明，用来理解变量提升；】 js语言特点提起JavaScript ，大家第一反应：脚本语言、解释性执行等，和java C这种编译性语言搭不上边。然而，事实上它确实是一门编译语言。只是区别在于JS并不会像其他的编译语言一样进行提前编译，他的编译过程（通常）是在实际执行前进行的，而且也不会产生可移植的编译结果。 通常的编译过程，会做以下几个步骤：首先是分词与词法分析，把输入的字符串分解为一些对编程语言有意义的代码块（词法单元）。第二步解析与语法分析，这一步的操作高级了许多，会将上一步的词法单元集合分析并最终转换为一个由元素逐级嵌套所组成的代表了程序语法结构的树，称为抽象语法树（Abstract Syntax Tree，AST）。第三步代码生成就是将上一步的AST转换为可执行代码。JavaScript引擎中的编译器做的事情与这个类似，但是因为JS引擎的编译过程就在代码执行前，对于“用户”来说是完全透明的。并且无法事先执行编译生成静态文件，因此JS的编译执行效率就要比一般静态语言敏感的多，故而也非常复杂。JS引擎在这一部分做了非常多的优化，一是针对语法分析和代码生成阶段进行优化（例如针对冗余元素进行优化等），目的是提高编译后的执行效率。二是针对编译过程进行优化（如JIT，延迟编译甚至重编译），目的是缩短编译过程，保证性能最佳。 引擎、编译器、作用域 引擎： 负责整个JS程序的编译及执行过程 编译器： 负责语法分析及代码生成等工作 作用域： 收集并维护由所有声明的标识符（变量）组成的一系列查询，实施一套非常严格的规则， 确定当前执行的代码对这些标识符的访问权限var a=2 编译器出马，先进行词法分析，将该赋值操作拆分： var a;a=2;。第一步 var a，编译器可以处理，他会先询问变量管家：作用域，是否存在一个该名称的变量？若存在，继续编译；若不存在，通知作用域声明一个新变量，命名为a。（这是在做变量提升） 编译器继续为引擎进行代码生成，这些代码主要用来处理 a=2这个赋值操作。 引擎拿到可执行代码，然后询问作用域：当前有没有一个叫a的变量啊? 如果有：使用这个变量，赋值给他；如果没有就继续往上级作用域查找，如果到根作用域仍然找不到，引擎直接报错抛异常 引擎在作用域中查找元素时有两种方式：LHS，RHS，当JavaScript引擎执行RHS查询时，如果在作用域链中都无法找到目标变量，不会在作用域中声明，那么，引擎会抛出ReferenceError异常。（见第二个例子与其他两个例子的区别） LHS查询：试图找到变量容器本身，从而可以对其进行赋值 RHS查询：查找某个变量的值对于一个赋值语句var a = b;，等号左侧进行LHS查询，等号右侧进行RHS查询；如果是一个普通的打印语句console.log(a)，那么，查找变量a属于RHS查询。 1234567891011//第一个例子b = 4;//LSH查询，在此处进行了变量声明console.log(b); //RHS查询//第二个例子console.log(b); //RSH查询，error，未查找到变量b，因为后面压根没有申明。b = 4; //LSH查询，//但是执行顺序上晚了？难道是解析一段代码执行一段代码的原因？不过感觉有点不对劲？//一条代码一条代码执行，给一个变量申明//第三个例子console.log(b); //RSH查询，查询到了变量b，对b进行了变量提升var b = 4; //undifined,变量提升//so在编译阶段，rsh查询可以没有申明过的变量给一个申明，又可以 包括变量和函数在内的所有声明都会在任何代码被执行前首先 被处理。进行变量提升。 词法作用域 ：介绍作用域时，我们有讲过其根据一套规则来管理变量的查找与引用，词法作用域就是js使用的规则，在编译器进行词法化时，其会根据你写代码时将变量和块作用域写在哪里，来决定规则的内容。这其中又包含了块作用域这个概念，不展开讲，只要记住ES6之前没有块作用域，只有函数作用于，即：函数内部是一个独立的块作用域。(有个特例：catch语句块内也是独立的作用域) 变量提升： 明白了编译器和引擎执行之间的分工，其实你应该就不会觉得变量提升是如此之诡异了，因为引擎拿到代码的时候，编译器已经做了一些转换（引擎旁白：这尼玛真怪不得我啊/(ㄒoㄒ)/~）。编译器干嘛要干这个事情？因为他要在第一步就找到所有的声明，并且用合适的作用域将他们关联起来，这也正是词法作用域的核心。表现为： 包括变量和函数在内的所有声明都会在当前块作用域内被首先处理，即类似于提升到最前面声明，但是复制处理操作因为是在执行阶段，因此编译阶段他们原地待命等待执行 。 参考链接1参考书籍：你不知道的jshttps://segmentfault.com/a/1190000013126460 静态作用域（又称词法作用域）与动态作用域静态作用域依赖与作用域链找到它的值 函数作用域链 [[Scope]] 属性下是一个数组，里面保存了，作用域链，此时只有一个 global/每个执行中的函数都有一个对应的作用域链/，作用域链最前端是该函数对应的变量对象，其次是嵌套函数的变量对象，最后是全局对象。与块级作用域联系起来，讲；JavaScript在查找一个变量时，即变量解析，会从对应作用域链的头部开始查，如果在头部指针指向的变量对象中找到该变量，则停止查询，采用找到的该变量的值。如果没有找到，则沿着链表逐级查询，直到查询到链表尾部节点对应的变量对象，即全局对象，如果最终没有查询到变量，则会报ReferenceError的错误。 块级作用域、函数作用域、全局作用域var能够变量提升；比较有意思的是for循环的例子啊；声明变量的几种方法，及动态声明变量的例子； 变量提升、函数提升函数表达式不能函数提升 创建函数的两种方式：函数声明与函数表达式（又称函数字面量）函数表达式其中还有立即执行函数；什么时候用函数申明好 什么时候用函数表达式呢？———————————————————————————————— 动态作用域与词法作用域123456789function foo() &#123; console.log( a );&#125;function bar() &#123; var a = 3; foo();&#125;var a = 2; bar();//什么状况，为什么是2，而不是undifined？啊，我知道了，上面那条是由于a=2留在原地等待执行，console执行在前，在此例中执行bar执行在后，不是说关注声明么，是的，关注声明只是让你找对容器，而容器里装什么与声明无关，所以并不矛盾。 如果在你看来，此处应该输出2（当然此处涉及到对于变量提升的理解），则说明你关注的是foo()的声明；如果你认为会输出3，则你关注的是函数的调用。借此例引出词法作用域和动态作用域的主要区别： 词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定 的。(this 也是!)词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。 如何理解运行时确定这个概念，bar()调用foo(),动态生成调用栈，基于调用栈生成作用域链，而不是基于代码中的作用域嵌套生成作用域链（词法作用域的做法）。 对于变量的查找，js是遵循词法作用域的，并且现在的大多数语言都是遵循词法作用域的。为什么js不使用动态作用域？我觉得一方面是因为，静态的更好控制，动态的不好控制。javascript引擎会在在编译阶段进行数项性能的优化。其中一些优化依赖于能够根据代码的词法进行静态的分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。 作用域嵌套当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用 域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量， 或抵达最外层的作用域(也就是全局作用域)为止。 12345678//作用域嵌套实例function bar() &#123; var a = 3; (function foo() &#123; console.log( a ); &#125;)()&#125;var a = 2; bar();//3 块级作用域函数作用域和全局作用域，都很好观察和理解。那什么是块级作用域？let 关键字可以将变量绑定到所在的任意作用域中（通常是{ .. }内部）。换句话说let为其声明的变量隐式地了所在的块作用域。同样的，const声明也可以创建块级作用域。 123456789101112131415161718//隐式创建块作用域var foo = true;if(foo)&#123; let bar = foo*2; console.log(bar);&#125;console.log(bar);//2 referrence error//显示的创建块作用域var foo = true;if(foo)&#123; &#123; let bar = foo*2; console.log(bar); &#125;&#125;console.log(bar);//2 referrence error 推荐使用显示创建块作用域。在这个例子中，我们在 if 声明内部显式地创建了一个块，如果需要对其进行重 构，整个块都可以被方便地移动而不会对外部 if 声明的位置和语义产生任何影响。 变量提升123456789101112//例1console.log(a);var a=2;//undifined//例2a=2;var a;console.log(a);//2//无关紧要的例3,非严格模式下的LSH查找，未查找到a的声明，会自动创建一个a的声明；a=2;console.log(a);//2 按照结果逆推，可以感觉到变量被声明到了顶部。实际上也是：引擎会在解释JavaScript代码之前首先对其进行编译。编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。（所以函数声明也能被提升）值得注意的是：第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。所以是undifinded。 闭包闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意 识地创建闭包。闭包的创建和使用在你的代码中随处可见。你缺少的是根据你自己的意愿来识别、拥抱和影响闭包的思维环境。 定义:当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 123456789function foo()&#123; var a = 2; function bar()&#123; console.log(a); &#125;; bar();&#125;foo(); //2 技术上来讲，也许是。但根据前面的定义，确切地说并不是。我认为最准确地用来解释 bar() 对 a 的引用的方法是词法作用域的查找规则，而这些规则只是闭包的一部分。(但却 是非常重要的一部分!)函数 bar() 具有一个涵盖 foo() 作用域的闭包。但是通过这种方式定义的闭包并不能直接进行观察，也无法明白在这个代码片段中闭包是 如何工作的。我们可以很容易地理解词法作用域，而闭包则隐藏在代码之后的神秘阴影 里，并不那么容易理解。 123456789function foo()&#123; var a = 2; function bar()&#123; console.log(a); &#125; return bar;&#125;var baz = foo(); //2 函数 bar() 的词法作用域能够访问 foo() 的内部作用域。然后我们将 bar() 函数本身当作 一个值类型进行传递。在这个例子中，我们将 bar 所引用的函数对象本身当作返回值。在 foo() 执行后，其返回值(也就是内部的 bar() 函数)赋值给变量 baz 并调用 baz()，实 际上只是通过不同的标识符引用调用了内部的函数 bar()。bar() 显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方执行。在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为我们知道引擎有垃 圾回收器用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以很 自然地会考虑对其进行回收。上一个作用域嵌套实现的闭包，foo()的内部作用域会被销毁而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此 没有被回收。谁在使用这个内部作用域?原来是 bar() 本身在使用。拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一 直存活，以供 bar() 在之后任何时间进行引用。bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。]]></content>
  </entry>
  <entry>
    <title><![CDATA[函数调用栈]]></title>
    <url>%2F2019%2F09%2F18%2F%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88%2F</url>
    <content type="text"><![CDATA[不同语言之间的转换 高级程序语言经过编译，变成汇编代码，汇编代码经过汇编器和连接器变成可执行的机器代码。汇编代码是人类可读的代码。机器代码是01序列。 在程序执行前，数据和指令事先存放在存储器中，每条指令和每个数据都有地址。程序启动后，计算机取指令执行。执行过程中，指令和数据从存储器取到CPU，存放到CPU寄存器中，CPU内的寄存器与控制器与ALU进行数据传送与运算，将运算结果写入内存中（存储器）。 寄存器IA-32体系中，有8个通用寄存器GPR，2个专用寄存器EIP和EFLAGs和六个段寄存器，间接给出段基址。 指令 计算机的指令有微指令、机器指令和伪指令之分。汇编指令是机器指令的符号表示，以帮助记忆，可以称之为助记符。机器指令和汇编指令是一一对应的，都是机器级指令。 机器指令对源操作数进行操作，操作结果储存到目的操作数中。操作码：操作性质；立即数：操作数在指令中给出，这个数叫做立即数。找到操作数或操作数的地址这个过程叫寻址，操作数在不同的位置，有不同的寻址方式。 将cl寄存器中的内容传送到该地址的存储单元中。 指令可以分为传送指令，如mov,push,pop,leal,in,out;定点算术运算指令，如add，sub，int,dec,neg,cmp;浮点运算指令等等。 函数调用过程一段c语言代码12345678910int add(int x,int y)&#123; return x+y;&#125;int main()&#123; int t1 = 125; int t2 = 80; int sum = add(t1,t2); return sum;&#125; 过程描述存放参数t1,t2;调出add执行，取出参数t1,t2,执行运算，保存返回结果，返回到main中。过程调用执行步骤（p为调用者，Q为被调用者） 关于Q过程中的保存P的现场和恢复P的现场为什么要压入返回地址啊？返回地址是指被调用函数的下一条语句。ret指令会将返回地址送到eip寄存器，即指令指针。 保存现场即保存寄存器，以便被调用者返回前恢复寄存器。根据IA-32的寄存器使用约定： 调用者保存寄存器：eax,edx,ecx如果调用函数P调用完Q返回后，还需用到eax寄存器，则需要P在调用Q前保存。*一般而言P调用Q之后不需要用到eax寄存器，所以一般会将操作数优先存在eax，edx，ecx这类寄存器，以减少准备阶段和结束阶段的开销。 被调用者保存寄存器：ebx，esi，edi如果被调用者Q需要用到ebx，则Q需要保存到栈中再使用。 ebp：帧指针寄存器，指向当前栈帧底部，高地址 esp：栈指针寄存器，指向当前栈帧顶部，低地址。如果以向上为高地址的话，栈就是个倒置的桶，栈帧底部abp描述的就是杯底，底部为高地址，没毛病。 栈和栈帧的变化 相应的汇编指令12345678910int add(int x,int y)&#123; return x+y;&#125;int caller()&#123; int t1 = 125; int t2 = 80; int sum = add(t1,t2); return sum;&#125; 汇编代码 操作 pushl %ebp 将旧ebp地址压栈（以便回到原栈底），esp地址-4，指向下一个存储单元 movl %esp,%ebp 将esp的值赋给ebp，ebp指向了当前栈帧的底部 subl $24,%esp 把esp减去了24，开辟内存空间 movl $125,-12(%ebp) 125送到ebp-12的位置 movl $80,-8(%ebp) 80这个立即数送到ebp-8的位置 movl -8(%ebp),%eax movl %eax,4(%esp) 把ebp-8的数送到esp+4的位置，在对t2参数进行赋值 movl -12(%ebp),%eax movl %eax,(%esp) 同理，在进行t1参数的赋值 call add 转入add函数体执行，同理第一二条指令是push ebp；mov esp,ebp形成add栈帧的底。return返回参数总是在eax中。call指令总会把下一条指令（movl %eax,-4(%ebp)）压入到栈中。add最后一条指令是ret指令，ret指令会将返回地址取出送到eip寄存器（指令指针）中。 movl %eax,-4(%ebp) 将eax的值（即return的和）传送至ebp-4的位置 movl -4(%ebp),%eax 把返回值sum再放入eax寄存器中 leave 退栈，将ebp的内容传送到esp，将esp又指向了ebp；再执行pop指令，把esp指向的内容弹出到ebp内，恢复ebp的内容（ebp回到了p过程的栈底）。esp指向上一个单元，该单元存放的是返回地址。 ret return指令又可以返回到p（调用函数）中执行 准备参数入口，将值再复制了一遍是为什么？假设回调函数为swap(&amp;t1,&amp;t2),要改变局部变量的之前是不是得先存起来，不然令t1=t2,t1原来的值消失了怎么办，简单比喻一下。]]></content>
  </entry>
  <entry>
    <title><![CDATA[栈堆]]></title>
    <url>%2F2019%2F09%2F16%2F%E6%A0%88%E5%A0%86%2F</url>
    <content type="text"><![CDATA[数据结构的栈和堆 栈：只能在表的一端进行插入和删除的线性表。具有先进后出的性质，可以理解为装数据的桶。 堆：经过排序的树形数据结构。 内存分配的栈和堆（以c++编译程序为例）存放区域 区域 作用 栈区（stack） 由编译器自动分配和释放，存放函数的参数值，局部变量的值等。操作方式类似与数据结构中的栈 堆区（heap） 一般由程序员分配和释放，若程序员不释放，程序结束时可能由操作系统回收。与数据结构中的堆是两码事，分配方式类似于链表。 全局区（静态区）（static） 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的还有一块区域。程序结束后由系统释放 文字常量区 常量字符串，程序结束后由系统释放 程序代码区 存放函数体的二进制代码 没有手动释放堆区的情况1 从C语言本身设计来说，不会释放。所谓动态内存，是由malloc系列函数进行申请的内存，除非在程序中使用free释放，否则该段内存不会被释放掉。从这个角度来说，即使进程结束，该段内存也会被占用。这种现象被称为内存泄露。2 大多数操作系统可以智能释放。动态内存由于是进程使用，向操作系统控制方申请的内存，所以操作系统内核可以记录哪些内存由哪个进程使用，这样为了减少内存泄露的危害，操作系统内核均实现了在进程退出后，进程分配的自用内存自动回收的机制。 来看一个例子1234567891011121314//main.cppint a = 0;//全局初始化区char *p1;//全局未初始化区，p1是以地址为数据么？main()&#123; int b;//栈 char s[] = "abc";//栈 “abc”也是在栈区么？还是在常量区？与p3的区别？数组在定义初始化的时候就在栈区开辟了一段连续的内存空间 char *p2 ;//栈 char *p3 = "123456";//p3在栈区；"12345\0"在常量区，为什么不在堆区？因为没有申请储存空间，只能存放在常量区 static int c =0; p1 = (char *)malloc(10); p2 = (char *)malloc(20);//分配得来得10和20字节的区域就在堆区。 strcpy(p1,"123456");//123456\0放在常量区。编译器可能会将它与p3所指向的"123456"优化成一个地方 strcpy(p2,"abcdef");//把常量区的"abcdef"拷贝一份到申请的堆区&#125; 申请后系统的响应 栈：仅仅要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 堆：首先应该知道操作系统有一个记录空暇内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空暇结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样。代码中的delete语句才干正确的释放本内存空间。所以堆是不连续的内存区域。（栈区和全局区的内存分布也不是连续的） 1234567891011121314151617#include &lt;stdio.h&gt;int g1=0, g2=0, g3=0;int main()&#123; static int s1=0, s2=0, s3=0; int v1=0, v2=0, v3=0; //打印出各个变量的内存地址 printf("0x%08x\n",&amp;v1);//打印各本地变量的内存地址 printf("0x%08x\n",&amp;v2); printf("0x%08x\n\n",&amp;v3); printf("0x%08x\n",&amp;g1); //打印各全局变量的内存地址 printf("0x%08x\n",&amp;g2); printf("0x%08x\n\n",&amp;g3); printf("0x%08x\n",&amp;s1); //打印各静态变量的内存地址 printf("0x%08x\n",&amp;s2); printf("0x%08x\n\n",&amp;s3); return 0;&#125; 另外。因为找到的堆结点的大小不一定正好等于申请的大小。系统会自己主动的将多余的那部分又一次放入空暇链表中。 能够申请的内存大小 栈：在Windows下,栈是向低地址扩展的数据结构。是一块连续的内存的区域栈顶的地址和栈的最大容量是系统预先规定好的。 堆：堆是向高地址扩展的数据结构，是不连续的内存区域。堆的大小受限于计算机系统中有效的虚拟内存。 参考链接]]></content>
  </entry>
  <entry>
    <title><![CDATA[muxi]]></title>
    <url>%2F2019%2F09%2F11%2Fmuxi%2F</url>
    <content type="text"><![CDATA[木犀前端机试在原有代码下增添代码实现如下效果动画效果图片无法展示要求 实现绿色盒子内文字的水平和垂直居中 鼠标悬停在蓝色盒子区域时对应区域透明度为0.3 使标题“task1”实现1.从右往左滑动进入页面的效果 2.滑动过程中颜色由红变黑 poem文字内容与边框间距为30px; poem文字区域在原位置上水平右移20px;垂直方向下移40px;注意不能使用margin，用margin做出的效果不同； 建议在编写代码之前，你需要有一个编辑器。 在线编辑器。 本地编辑器vscode下载地址 参考资料 MDN HTML 入门 MDN HTML 元素 w3school CSS 教程 CSS水平垂直居中常见方法总结]]></content>
      <categories>
        <category>Task</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[webpack-2]]></title>
    <url>%2F2019%2F08%2F21%2Fwebpack-2%2F</url>
    <content type="text"><![CDATA[开发环境 mode: &#39;development&#39;, devtool: &#39;inline-source-map&#39;,……plugins: [ 使用 source map ，准确地知道错误来自于哪个源文件， watch mode npm run watch 浏览器可自动更新 webpack-dev-server/webpack-dev-middleware 对server.js文件进行配置，npm start 在3000端口运行此时dist文件夹不会有文件，而是生成在浏览器的缓存中。]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[木犀机试]]></title>
    <url>%2F2019%2F08%2F21%2Fmy-new-post%2F</url>
    <content type="text"><![CDATA[木犀前端机试在原有代码下增添代码实现如下效果![效果图片](./images/muxi.png）动画效果图片无法展示要求 实现绿色盒子内文字的水平和垂直居中 鼠标悬停在蓝色盒子区域时对应区域透明度为0.3 使标题“task1”实现1.从右往左滑动进入页面的效果 2.滑动过程中颜色由红变黑 poem文字内容与边框间距为30px; poem文字区域在原位置上水平右移20px;垂直方向下移40px;注意不能使用margin，用margin做出的效果不同； 建议在编写代码之前，你需要有一个编辑器。 在线编辑器。 本地编辑器vscode下载地址 参考资料 MDN HTML 入门 MDN HTML 元素 w3school CSS 教程 CSS水平垂直居中常见方法总结]]></content>
      <categories>
        <category>Task</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[webpack学习笔记]]></title>
    <url>%2F2019%2F08%2F08%2Fwebpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[[TOC]看懂webpack.config.js entry 123module.exports=&#123; entry:'./path/to/my/entry/file.js'&#125;；默认值是./src/index.js;入口起点 output 12345678const path = require('path');module.exports = &#123; entry: './path/to/my/entry/file.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'my-first-webpack.bundle.js' &#125;&#125;; path定义导入的模块，filename指bunble生成的名件名称及地址。输出文件默认放入./dist文件夹中 loader loader 能够import任何类型的模块，例如css。 123456789101112const path = require('path');module.exports = &#123; output: &#123; filename: 'my-first-webpack.bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\.txt$/, use: 'raw-loader' &#125; ] &#125;&#125;; “嘿，webpack 编译器，当你碰到「在 require()/import 语句中被解析为 ‘.txt’ 的路径」时，在你对它打包之前，先 &gt;使用 raw-loader 转换一下。” plugin 12345678910111213const HtmlWebpackPlugin = require('html-webpack-plugin'); // 通过 npm 安装const webpack = require('webpack'); // 用于访问内置插件module.exports = &#123; module: &#123; rules: [ &#123; test: /\.txt$/, use: 'raw-loader' &#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;) ]&#125;; 该插件为应用程序生成html文件，并注入所有生成的bundle。 资源管理以加载images图像为例 npm install --save-dev file-loader webpack.config 12345678910111213module.exports = &#123; .... module: &#123; rules: [ &#123; test: /\.(png|svg|jpg|gif)$/, use: [ 'file-loader' &#125; ] &#125;&#125; src/icon.jpg src/index.js 1234567891011121314import _ from 'lodash';import './style.css';import Icon from './icon.png';function component() &#123; var element = document.createElement('div'); // lodash，现在由此脚本导入 element.innerHTML = _.join(['Hello', 'webpack'], ' '); element.classList.add('hello'); var myIcon = new Image(); myIcon.src = Icon; element.appendChild(myIcon); src/style.css 123.hello&#123; background: url('./icon.png');&#125; npm run build 其他加载，css，fonts，data。 管理输出 以下插件/操作均为方便管理dist文件夹，不需要手动更改 动态生成bunble.js文件 1234567891011121314const path = require('path'); module.exports = &#123;- entry: './src/index.js',+ entry: &#123;+ app: './src/index.js',+ print: './src/print.js'+ &#125;, output: &#123;- filename: 'bundle.js',+ filename: '[name].bundle.js', path: path.resolve(__dirname, 'dist') &#125; &#125;; npm install --save-dev html-webpack-plugin 123456789101112131415161718 const path = require('path');+ const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = &#123; entry: &#123; app: './src/index.js', print: './src/print.js' &#125;,+ plugins: [+ new HtmlWebpackPlugin(&#123;+ title: '管理输出'+ &#125;)+ ], output: &#123; filename: '[name].bundle.js', path: path.resolve(__dirname, 'dist') &#125; &#125;; 执行npm run build该插件会默认生成index.html文件，覆盖/更改原index.html文件 npm install --save-dev clean-webpack-plugin 123456+ const CleanWebpackPlugin = require('clean-webpack-plugin');//需改为&#123;CleanWebpackPlugin&#125;,否则会有报错.... plugins: [+ new CleanWebpackPlugin(), 作用为清理dist文件夹中之前生成的不需要的旧文件。这一节管理输出一直有报错，未能正常显示页面 1234567891011121314Uncaught ReferenceError: ducument is not defined at app.bundle.js:9 at Module.&lt;anonymous&gt; (app.bundle.js:9) at r (app.bundle.js:1) at app.bundle.js:1 at app.bundle.js:1(anonymous) @ app.bundle.js:9(anonymous) @ app.bundle.js:9r @ app.bundle.js:1(anonymous) @ app.bundle.js:1(anonymous) @ app.bundle.js:1//浏览器报错Entrypoint undefined = index.html//终端报错，有人说是插件本身的问题 按照官网操作来的，这报错真的不明白，之后再看看怎么解决唔，看看github相关插件的issue 吐血！document拼写错误，见devtool: &#39;inline-source-map&#39;,可跟踪错误至源文件]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
</search>
