<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[函数调用栈]]></title>
    <url>%2F2019%2F09%2F18%2F%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88%2F</url>
    <content type="text"><![CDATA[不同语言之间的转换 高级程序语言经过编译，变成汇编代码，汇编代码经过汇编器和连接器变成可执行的机器代码。汇编代码是人类可读的代码。机器代码是01序列。 在程序执行前，数据和指令事先存放在存储器中，每条指令和每个数据都有地址。程序启动后，计算机取指令执行。执行过程中，指令和数据从存储器取到CPU，存放到CPU寄存器中，CPU内的寄存器与控制器与ALU进行数据传送与运算，将运算结果写入内存中（存储器）。 寄存器IA-32体系中，有8个通用寄存器GPR，2个专用寄存器EIP和EFLAGs和六个段寄存器，间接给出段基址。 指令 计算机的指令有微指令、机器指令和伪指令之分。汇编指令是机器指令的符号表示，以帮助记忆，可以称之为助记符。机器指令和汇编指令是一一对应的，都是机器级指令。 机器指令对源操作数进行操作，操作结果储存到目的操作数中。操作码：操作性质；立即数：操作数在指令中给出，这个数叫做立即数。找到操作数或操作数的地址这个过程叫寻址，操作数在不同的位置，有不同的寻址方式。 将cl寄存器中的内容传送到该地址的存储单元中。 指令可以分为传送指令，如mov,push,pop,leal,in,out;定点算术运算指令，如add，sub，int,dec,neg,cmp;浮点运算指令等等。 函数调用过程一段c语言代码12345678910int add(int x,int y)&#123; return x+y;&#125;int main()&#123; int t1 = 125; int t2 = 80; int sum = add(t1,t2); return sum;&#125; 过程描述存放参数t1,t2;调出add执行，取出参数t1,t2,执行运算，保存返回结果，返回到main中。过程调用执行步骤（p为调用者，Q为被调用者） 关于Q过程中的保存P的现场和恢复P的现场为什么要压入返回地址啊？返回地址是指被调用函数的下一条语句。ret指令会将返回地址送到eip寄存器，即指令指针。 保存现场即保存寄存器，以便被调用者返回前恢复寄存器。根据IA-32的寄存器使用约定： 调用者保存寄存器：eax,edx,ecx如果调用函数P调用完Q返回后，还需用到eax寄存器，则需要P在调用Q前保存。*一般而言P调用Q之后不需要用到eax寄存器，所以一般会将操作数优先存在eax，edx，ecx这类寄存器，以减少准备阶段和结束阶段的开销。 被调用者保存寄存器：ebx，esi，edi如果被调用者Q需要用到ebx，则Q需要保存到栈中再使用。 ebp：帧指针寄存器，指向当前栈帧底部，高地址 esp：栈指针寄存器，指向当前栈帧顶部，低地址。如果以向上为高地址的话，栈就是个倒置的桶，栈帧底部abp描述的就是杯底，底部为高地址，没毛病。 栈和栈帧的变化 相应的汇编指令12345678910int add(int x,int y)&#123; return x+y;&#125;int caller()&#123; int t1 = 125; int t2 = 80; int sum = add(t1,t2); return sum;&#125; 汇编代码 操作 pushl %ebp 将旧ebp地址压栈（以便回到原栈底），esp地址-4，指向下一个存储单元 movl %esp,%ebp 将esp的值赋给ebp，ebp指向了当前栈帧的底部 subl $24,%esp 把esp减去了24，开辟内存空间 movl $125,-12(%ebp) 125送到ebp-12的位置 movl $80,-8(%ebp) 80这个立即数送到ebp-8的位置 movl -8(%ebp),%eax movl %eax,4(%esp) 把ebp-8的数送到esp+4的位置，在对t2参数进行赋值 movl -12(%ebp),%eax movl %eax,(%esp) 同理，在进行t1参数的赋值 call add 转入add函数体执行，同理第一二条指令是push ebp；mov esp,ebp形成add栈帧的底。return返回参数总是在eax中。call指令总会把下一条指令（movl %eax,-4(%ebp)）压入到栈中。add最后一条指令是ret指令，ret指令会将返回地址取出送到eip寄存器（指令指针）中。 movl %eax,-4(%ebp) 将eax的值（即return的和）传送至ebp-4的位置 movl -4(%ebp),%eax 把返回值sum再放入eax寄存器中 leave 退栈，将ebp的内容传送到esp，将esp又指向了ebp；再执行pop指令，把esp指向的内容弹出到ebp内，恢复ebp的内容（ebp回到了p过程的栈底）。esp指向上一个单元，该单元存放的是返回地址。 ret return指令又可以返回到p（调用函数）中执行 准备参数入口，将值再复制了一遍是为什么？假设回调函数为swap(&amp;t1,&amp;t2),要改变局部变量的之前是不是得先存起来，不然令t1=t2,t1原来的值消失了怎么办，简单比喻一下。]]></content>
  </entry>
  <entry>
    <title><![CDATA[栈堆]]></title>
    <url>%2F2019%2F09%2F16%2F%E6%A0%88%E5%A0%86%2F</url>
    <content type="text"><![CDATA[数据结构的栈和堆 栈：只能在表的一端进行插入和删除的线性表。具有先进后出的性质，可以理解为装数据的桶。 堆：经过排序的树形数据结构。 内存分配的栈和堆（以c++编译程序为例）存放区域 区域 作用 栈区（stack） 由编译器自动分配和释放，存放函数的参数值，局部变量的值等。操作方式类似与数据结构中的栈 堆区（heap） 一般由程序员分配和释放，若程序员不释放，程序结束时可能由操作系统回收。与数据结构中的堆是两码事，分配方式类似于链表。 全局区（静态区）（static） 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的还有一块区域。程序结束后由系统释放 文字常量区 常量字符串，程序结束后由系统释放 程序代码区 存放函数体的二进制代码 没有手动释放堆区的情况1 从C语言本身设计来说，不会释放。所谓动态内存，是由malloc系列函数进行申请的内存，除非在程序中使用free释放，否则该段内存不会被释放掉。从这个角度来说，即使进程结束，该段内存也会被占用。这种现象被称为内存泄露。2 大多数操作系统可以智能释放。动态内存由于是进程使用，向操作系统控制方申请的内存，所以操作系统内核可以记录哪些内存由哪个进程使用，这样为了减少内存泄露的危害，操作系统内核均实现了在进程退出后，进程分配的自用内存自动回收的机制。 来看一个例子1234567891011121314//main.cppint a = 0;//全局初始化区char *p1;//全局未初始化区，p1是以地址为数据么？main()&#123; int b;//栈 char s[] = "abc";//栈 “abc”也是在栈区么？还是在常量区？与p3的区别？数组在定义初始化的时候就在栈区开辟了一段连续的内存空间 char *p2 ;//栈 char *p3 = "123456";//p3在栈区；"12345\0"在常量区，为什么不在堆区？因为没有申请储存空间，只能存放在常量区 static int c =0; p1 = (char *)malloc(10); p2 = (char *)malloc(20);//分配得来得10和20字节的区域就在堆区。 strcpy(p1,"123456");//123456\0放在常量区。编译器可能会将它与p3所指向的"123456"优化成一个地方 strcpy(p2,"abcdef");//把常量区的"abcdef"拷贝一份到申请的堆区&#125; 申请后系统的响应 栈：仅仅要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 堆：首先应该知道操作系统有一个记录空暇内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空暇结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样。代码中的delete语句才干正确的释放本内存空间。所以堆是不连续的内存区域。（栈区和全局区的内存分布也不是连续的） 1234567891011121314151617#include &lt;stdio.h&gt;int g1=0, g2=0, g3=0;int main()&#123; static int s1=0, s2=0, s3=0; int v1=0, v2=0, v3=0; //打印出各个变量的内存地址 printf("0x%08x\n",&amp;v1);//打印各本地变量的内存地址 printf("0x%08x\n",&amp;v2); printf("0x%08x\n\n",&amp;v3); printf("0x%08x\n",&amp;g1); //打印各全局变量的内存地址 printf("0x%08x\n",&amp;g2); printf("0x%08x\n\n",&amp;g3); printf("0x%08x\n",&amp;s1); //打印各静态变量的内存地址 printf("0x%08x\n",&amp;s2); printf("0x%08x\n\n",&amp;s3); return 0;&#125; 另外。因为找到的堆结点的大小不一定正好等于申请的大小。系统会自己主动的将多余的那部分又一次放入空暇链表中。 能够申请的内存大小 栈：在Windows下,栈是向低地址扩展的数据结构。是一块连续的内存的区域栈顶的地址和栈的最大容量是系统预先规定好的。 堆：堆是向高地址扩展的数据结构，是不连续的内存区域。堆的大小受限于计算机系统中有效的虚拟内存。 参考链接]]></content>
  </entry>
  <entry>
    <title><![CDATA[muxi]]></title>
    <url>%2F2019%2F09%2F11%2Fmuxi%2F</url>
    <content type="text"><![CDATA[木犀前端机试在原有代码下增添代码实现如下效果动画效果图片无法展示要求 实现绿色盒子内文字的水平和垂直居中 鼠标悬停在蓝色盒子区域时对应区域透明度为0.3 使标题“task1”实现1.从右往左滑动进入页面的效果 2.滑动过程中颜色由红变黑 poem文字内容与边框间距为30px; poem文字区域在原位置上水平右移20px;垂直方向下移40px;注意不能使用margin，用margin做出的效果不同； 建议在编写代码之前，你需要有一个编辑器。 在线编辑器。 本地编辑器vscode下载地址 参考资料 MDN HTML 入门 MDN HTML 元素 w3school CSS 教程 CSS水平垂直居中常见方法总结]]></content>
      <categories>
        <category>Task</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[webpack-2]]></title>
    <url>%2F2019%2F08%2F21%2Fwebpack-2%2F</url>
    <content type="text"><![CDATA[开发环境 mode: &#39;development&#39;, devtool: &#39;inline-source-map&#39;,……plugins: [ 使用 source map ，准确地知道错误来自于哪个源文件， watch mode npm run watch 浏览器可自动更新 webpack-dev-server/webpack-dev-middleware 对server.js文件进行配置，npm start 在3000端口运行此时dist文件夹不会有文件，而是生成在浏览器的缓存中。]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[木犀机试]]></title>
    <url>%2F2019%2F08%2F21%2Fmy-new-post%2F</url>
    <content type="text"><![CDATA[木犀前端机试在原有代码下增添代码实现如下效果![效果图片](./images/muxi.png）动画效果图片无法展示要求 实现绿色盒子内文字的水平和垂直居中 鼠标悬停在蓝色盒子区域时对应区域透明度为0.3 使标题“task1”实现1.从右往左滑动进入页面的效果 2.滑动过程中颜色由红变黑 poem文字内容与边框间距为30px; poem文字区域在原位置上水平右移20px;垂直方向下移40px;注意不能使用margin，用margin做出的效果不同； 建议在编写代码之前，你需要有一个编辑器。 在线编辑器。 本地编辑器vscode下载地址 参考资料 MDN HTML 入门 MDN HTML 元素 w3school CSS 教程 CSS水平垂直居中常见方法总结]]></content>
      <categories>
        <category>Task</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[webpack学习笔记]]></title>
    <url>%2F2019%2F08%2F08%2Fwebpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[[TOC]看懂webpack.config.js entry 123module.exports=&#123; entry:'./path/to/my/entry/file.js'&#125;；默认值是./src/index.js;入口起点 output 12345678const path = require('path');module.exports = &#123; entry: './path/to/my/entry/file.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'my-first-webpack.bundle.js' &#125;&#125;; path定义导入的模块，filename指bunble生成的名件名称及地址。输出文件默认放入./dist文件夹中 loader loader 能够import任何类型的模块，例如css。 123456789101112const path = require('path');module.exports = &#123; output: &#123; filename: 'my-first-webpack.bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\.txt$/, use: 'raw-loader' &#125; ] &#125;&#125;; “嘿，webpack 编译器，当你碰到「在 require()/import 语句中被解析为 ‘.txt’ 的路径」时，在你对它打包之前，先 &gt;使用 raw-loader 转换一下。” plugin 12345678910111213const HtmlWebpackPlugin = require('html-webpack-plugin'); // 通过 npm 安装const webpack = require('webpack'); // 用于访问内置插件module.exports = &#123; module: &#123; rules: [ &#123; test: /\.txt$/, use: 'raw-loader' &#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;) ]&#125;; 该插件为应用程序生成html文件，并注入所有生成的bundle。 资源管理以加载images图像为例 npm install --save-dev file-loader webpack.config 12345678910111213module.exports = &#123; .... module: &#123; rules: [ &#123; test: /\.(png|svg|jpg|gif)$/, use: [ 'file-loader' &#125; ] &#125;&#125; src/icon.jpg src/index.js 1234567891011121314import _ from 'lodash';import './style.css';import Icon from './icon.png';function component() &#123; var element = document.createElement('div'); // lodash，现在由此脚本导入 element.innerHTML = _.join(['Hello', 'webpack'], ' '); element.classList.add('hello'); var myIcon = new Image(); myIcon.src = Icon; element.appendChild(myIcon); src/style.css 123.hello&#123; background: url('./icon.png');&#125; npm run build 其他加载，css，fonts，data。 管理输出 以下插件/操作均为方便管理dist文件夹，不需要手动更改 动态生成bunble.js文件 1234567891011121314const path = require('path'); module.exports = &#123;- entry: './src/index.js',+ entry: &#123;+ app: './src/index.js',+ print: './src/print.js'+ &#125;, output: &#123;- filename: 'bundle.js',+ filename: '[name].bundle.js', path: path.resolve(__dirname, 'dist') &#125; &#125;; npm install --save-dev html-webpack-plugin 123456789101112131415161718 const path = require('path');+ const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = &#123; entry: &#123; app: './src/index.js', print: './src/print.js' &#125;,+ plugins: [+ new HtmlWebpackPlugin(&#123;+ title: '管理输出'+ &#125;)+ ], output: &#123; filename: '[name].bundle.js', path: path.resolve(__dirname, 'dist') &#125; &#125;; 执行npm run build该插件会默认生成index.html文件，覆盖/更改原index.html文件 npm install --save-dev clean-webpack-plugin 123456+ const CleanWebpackPlugin = require('clean-webpack-plugin');//需改为&#123;CleanWebpackPlugin&#125;,否则会有报错.... plugins: [+ new CleanWebpackPlugin(), 作用为清理dist文件夹中之前生成的不需要的旧文件。这一节管理输出一直有报错，未能正常显示页面 1234567891011121314Uncaught ReferenceError: ducument is not defined at app.bundle.js:9 at Module.&lt;anonymous&gt; (app.bundle.js:9) at r (app.bundle.js:1) at app.bundle.js:1 at app.bundle.js:1(anonymous) @ app.bundle.js:9(anonymous) @ app.bundle.js:9r @ app.bundle.js:1(anonymous) @ app.bundle.js:1(anonymous) @ app.bundle.js:1//浏览器报错Entrypoint undefined = index.html//终端报错，有人说是插件本身的问题 按照官网操作来的，这报错真的不明白，之后再看看怎么解决唔，看看github相关插件的issue 吐血！document拼写错误，见devtool: &#39;inline-source-map&#39;,可跟踪错误至源文件]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
</search>
